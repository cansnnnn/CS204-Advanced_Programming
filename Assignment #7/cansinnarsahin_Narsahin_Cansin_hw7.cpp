#include <iostream>
#include <string>
#include <thread>
#include <mutex>
#include <random> 
#include <time.h>
#include <chrono>
#include <ctime>  
#include <iomanip>
#include "cansinnarsahin_Narsahin_Cansin_hw7_PrintQueue.h"

using namespace std;

mutex que_mutex;	//for accessing the shared queue object
mutex output_mutex; //for tidy outputs
HW7PrintQueue printer_que;

int random_range(const int & min, const int & max) 
{ 
	//from pdf to generate random number

	static mt19937 generator(time(0)); 
	uniform_int_distribution<int> distribution(min, max); 
	return distribution(generator); 
}

void beginning(int & max_printjobs, int & min_waiting,
			   int & max_waiting,int &  min_pages, int & max_pages)
{
	//for the cout lines that executes at the beginning of the program
	//also takes values

	cout<<"Please enter the max number of print jobs: ";
	cin>>max_printjobs;
	cout<<"Please enter the min and max values for the waiting time period (in seconds) after creating a print job:"<<endl;
	cout<<"Min: ";
	cin>>min_waiting;
	cout<<"Max: ";
	cin>>max_waiting;
	cout<<"Please enter the min and max values for the number of pages in a print job:"<<endl;
	cout<<"Min number of pages: ";
	cin>>min_pages;
	cout<<"Max number of pages: ";
	cin>>max_pages;

}

void current_time()
{//prints current time as a string in hh:mm:ss format

	//from Lecture Notes -> threads8.cpp file
	time_t tt = chrono::system_clock::to_time_t (chrono::system_clock::now());
	struct tm *ptm = new struct tm;  
	localtime_s(ptm, &tt);  
	cout << put_time(ptm,"%X") << endl; 
	// end of code from Lecture Notes -> threads8.cpp file

}

void printer_function(int & id, int & page_num)
{
	//The printer will then take the print jobs from 
	//the front of the queue (dequeue) and process it.

	que_mutex.lock();
	printer_que.dequeue(id,page_num);
	que_mutex.unlock();

	output_mutex.lock();
	cout<<"The printer started to print the job with ID:  "<<id<<", number of pages: "<<page_num
		<<" (queue size is: "<<printer_que.getCurrentSize()<<") ";
	current_time();		// prints current time and enter
	output_mutex.unlock();

	
	this_thread::sleep_for (chrono::seconds(page_num)); //one page takes one second to print
	
	output_mutex.lock();
	cout<<"The printer finished printing the job with ID: "<<id<<", number of pages: "<<page_num<<" ";
	current_time();		// prints current time and enter
	output_mutex.unlock();
}

void user_function(int user, int id, int *min_max_pages, int *min_max_times,int & page_number)
{
	//In the user threads, print jobs with a random number of pages
	//will be generated by the users and then the users will enqueue 
	//the print jobs to the rear of the queue.

	int min_pages=min_max_pages[0];
	int max_pages=min_max_pages[1];
	int min_time=min_max_times[0];
	int max_time=min_max_times[1];

	page_number= random_range(min_pages,max_pages); //generates random page numbers
	
	que_mutex.lock();
	printer_que.enqueue(id,page_number);
	que_mutex.unlock();

	output_mutex.lock();
	cout<<"User "<<user<<" sent new print job with ID "<<id<<" sent to the printer queue, number of pages: "
		<<page_number<<" (print queue size: "<<printer_que.getCurrentSize()<<")	";
	current_time();		// prints current time and enter
	output_mutex.unlock();

	int waiting_time=random_range(min_time,max_time); //generates random time to wait
	this_thread::sleep_for (chrono::seconds(waiting_time));

}

int main()
{
	int max_printjobs, min_waiting, max_waiting, min_pages, max_pages;

	beginning(max_printjobs, min_waiting, max_waiting, min_pages, max_pages); //cout/ cin part

	//arrays for variables
	int *min_max_pages = new int(2);
	int *min_max_times = new int(2);
	min_max_pages[0]= min_pages;
	min_max_pages[1]=max_pages;
	min_max_times[0]=min_waiting;
	min_max_times[1]=max_waiting;


	cout<<"Simulation starts ";
	current_time(); // prints current time and enter

	thread user_threads[3]; 
	thread printer_thread;

	for(int print_times=0; print_times<max_printjobs;print_times++)
	{
		int id= print_times+1;
		int current_user=random_range(1,3); //generatees a random user between 1 and 3
		
		int page_number;

		user_threads[current_user-1] = (thread(&user_function,current_user, id, 
			min_max_pages, min_max_times,ref(page_number)));
		user_threads[current_user-1].join(); //waits for page num to send it to printer function

		printer_thread=(thread(&printer_function,ref(id),ref(page_number)));
		printer_thread.join();
	}

	return 0;
}
